alpha = 0.9
) +
labs(
title = "MONTOS AGRUPADOS (Histograma)",
x = "Monto del contrato (Agrupado)",
y = "Frecuencia"
) +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
axis.title.x = element_text(face = "bold"),
axis.title.y = element_text(face = "bold"),
panel.background = element_rect(fill = "#00BFC4", color = NA),
plot.background = element_rect(fill = "#00BFC4", color = NA),
panel.grid.major = element_line(color = "white"),
panel.grid.minor = element_blank(),
axis.text = element_text(color = "black"),
axis.line = element_line(color = "black")
)
}
if ("Monto" %in% names(datos)) {
ggplot(datos_filtrado, aes(x = Monto)) +
geom_histogram(
bins = 10,
fill = "grey70",
color = "black",
alpha = 0.9
) +
labs(
title = "CANTIDAD DE MONTOS EN CONTRATACIONES",
x = "Monto del contrato (Agrupado)",
y = "Frecuencia de montos"
) +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
axis.title.x = element_text(face = "bold"),
axis.title.y = element_text(face = "bold"),
panel.background = element_rect(fill = "#00BFC4", color = NA),
plot.background = element_rect(fill = "#00BFC4", color = NA),
panel.grid.major = element_line(color = "white"),
panel.grid.minor = element_blank(),
axis.text = element_text(color = "black"),
axis.line = element_line(color = "black")
)
}
if (exists("tabla_frecuencia")) {
library(ggplot2)
library(dplyr)
limites <- tabla_frecuencia %>%
mutate(PuntoMedio = (Limite_Inferior + Limite_Superior) / 2)
ggplot(limites, aes(x = as.factor(1), y = PuntoMedio)) +
geom_boxplot(fill = "#69b3a2", color = "black", width = 0.3, outlier.color = "red", outlier.shape = 16) +
labs(
title = "Montos de Contratos",
x = "Cantidad de Contratos",
y = "Montos Totales (S/)"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.text.x = element_blank()
)
} else {
cat("‚ö†Ô∏è No existe el objeto 'tabla_frecuencia'. Carga o genera primero la tabla de frecuencias.")
}
# Crear resumen con la cantidad de registros por Tipo_Orden
resumen <- datos %>%
count(Tipo_Orden, name = "Cantidad")
# Crear resumen con la cantidad de registros por Tipo_Orden
resumen <- datos %>%
count(Tipo_Orden, name = "Cantidad")
# Filtrar anuladas
anuladas <- datos %>% filter(Estado == "Anulada")
# Filtrar anuladas
anuladas <- datos %>% filter(Estado == "Anulada")
anuladas <- datos %>%
filter(Estado == "Anulada")
library(dplyr)
library(ggplot2)
library(scales)
# --- Verificaciones b√°sicas ---
if (!exists("datos")) stop("El objeto 'datos' no existe. Carga tu dataset antes de ejecutar este chunk.")
required_cols <- c("Estado", "Tipo_Orden")
miss <- setdiff(required_cols, names(datos))
if (length(miss) > 0) stop(paste("Faltan columnas en 'datos':", paste(miss, collapse = ", ")))
library(dplyr)
library(ggplot2)
library(scales)
# Filtrar √≥rdenes anuladas
anuladas <- datos %>%
filter(Estado == "Anulada")
# Estad√≠sticas b√°sicas
total_ordenes <- nrow(datos)
total_anuladas <- nrow(anuladas)
porcentaje_anuladas <- round((total_anuladas / total_ordenes) * 100, 2)
# Si hay m√°s de una orden anulada
if (nrow(anuladas) > 1) {
# Agrupar y contar por proveedor (puedes cambiar el nombre de columna)
resumen <- anuladas %>%
group_by(Proveedor) %>%
summarise(Cantidad = n())
p2 <- ggplot(resumen, aes(x = reorder(Proveedor, Cantidad),
y = Cantidad, fill = Proveedor)) +
geom_col(alpha = 0.8) +
geom_text(aes(label = Cantidad), hjust = -0.1, fontface = "bold") +
coord_flip() +
labs(title = "Cantidad de √ìrdenes Anuladas por Proveedor",
x = "Proveedor", y = "Cantidad de √ìrdenes") +
scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold"))
print(p2)
} else if (total_anuladas > 0) {
Anuladas1 <- ggplot(anuladas, aes(x = Proveedor, y = Monto_limpio, fill = Proveedor)) +
geom_col(alpha = 0.8) +
geom_text(aes(label = paste0("S/. ", comma(Monto_limpio))),
vjust = -0.3, fontface = "bold") +
labs(title = paste0("√ìrdenes Anuladas (", total_anuladas, " casos)"),
x = "Proveedor", y = "Monto (S/.)") +
scale_y_continuous(labels = function(x) paste0("S/. ", comma(x)),
expand = expansion(mult = c(0, 0.15))) +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold"))
ggsave("Anuladas1.png", plot = Anuladas1, width = 8, height = 6, dpi = 300)
print(Anuladas1)
}
library(randomForest)
library(caret)
# Crear dataset para predecir √≥rdenes sospechosas
datos_modelo <- datos %>%
left_join(concentracion_proveedores, by = "RUC") %>%
mutate(
Es_Sospechoso = ifelse(
RUC %in% score_integral$RUC |
RUC %in% casos_fraccionamiento$RUC,
1, 0
),
Mes = month(Fecha_Emision),
Es_Fin_A√±o = ifelse(Mes >= 11, 1, 0),
Dias_Desde_Inicio = as.numeric(Fecha_Emision - min(Fecha_Emision)),
Monto_Normalizado = scale(Monto_limpio)[,1]
) %>%
filter(!is.na(Es_Sospechoso))
library(randomForest)
library(caret)
datos_modelo <- datos %>%
mutate(
Es_Sospechoso = ifelse(
RUC %in% score_integral$RUC |
RUC %in% casos_fraccionamiento$RUC,
1, 0
),
Mes = month(Fecha_Emision),
Es_Fin_A√±o = ifelse(Mes >= 11, 1, 0),
Dias_Desde_Inicio = as.numeric(Fecha_Emision - min(Fecha_Emision)),
Monto_Normalizado = scale(Monto_limpio)[,1],
Participacion_Mercado = 0  # valor ficticio temporal
) %>%
filter(!is.na(Es_Sospechoso))
library(dplyr)
library(ggplot2)
library(caret)
library(randomForest)
library(lubridate)
library(scales)
# üü© Verifica que esta columna exista (ajusta el nombre si difiere)
# Ejecuta: colnames(datos) y reemplaza "RUC" si se llama distinto
datos_modelo <- datos %>%
mutate(
Es_Sospechoso = ifelse(
RUC %in% score_integral$RUC |
RUC %in% casos_fraccionamiento$RUC,
1, 0
),
Mes = month(Fecha_Emision),
Es_Fin_A√±o = ifelse(Mes >= 11, 1, 0),
Dias_Desde_Inicio = as.numeric(Fecha_Emision - min(Fecha_Emision, na.rm = TRUE)),
Monto_Normalizado = as.numeric(scale(Monto_limpio)[,1]),
Participacion_Mercado = 0  # Valor temporal
) %>%
filter(!is.na(Es_Sospechoso))
colnames(datos)
colnames(score_integral)
colnames(datos)
colnames(casos_fraccionamiento)
colnames(datos)
library(dplyr)
library(ggplot2)
library(caret)
library(randomForest)
library(lubridate)
library(scales)
# Aseg√∫rate de que 'score_integral' y 'casos_fraccionamiento' tambi√©n usen la misma columna: "Contratista"
# Si no, ajusta sus nombres al final del c√≥digo
datos_modelo <- datos %>%
mutate(
Es_Sospechoso = ifelse(
Contratista %in% score_integral$Contratista |
Contratista %in% casos_fraccionamiento$Contratista,
1, 0
),
# Convertir las fechas correctamente
Fecha_Emision = as.Date(`Fecha de suscripci√≥n del contrato`, format = "%Y-%m-%d"),
Mes = month(Fecha_Emision),
Es_Fin_A√±o = ifelse(Mes >= 11, 1, 0),
Dias_Desde_Inicio = as.numeric(Fecha_Emision - min(Fecha_Emision, na.rm = TRUE)),
Monto_limpio = as.numeric(gsub("[^0-9.]", "", Monto)),  # limpiar Monto si tiene s√≠mbolos
Monto_Normalizado = as.numeric(scale(Monto_limpio)[, 1]),
Participacion_Mercado = 0  # Valor temporal
) %>%
filter(!is.na(Es_Sospechoso))
library(dplyr)
library(lubridate)
library(randomForest)
library(caret)
library(ggplot2)
# --- Preparar vectores seguros desde score_integral y casos_fraccionamiento ---
# Si los objetos no existen o no tienen las columnas esperadas, quedan vac√≠os.
score_rucs <- character(0)
if (exists("score_integral")) {
if ("Contratista" %in% names(score_integral)) score_rucs <- as.character(score_integral$Contratista)
else if ("RUC" %in% names(score_integral)) score_rucs <- as.character(score_integral$RUC)
}
casos_rucs <- character(0)
if (exists("casos_fraccionamiento")) {
if ("Contratista" %in% names(casos_fraccionamiento)) casos_rucs <- as.character(casos_fraccionamiento$Contratista)
else if ("RUC" %in% names(casos_fraccionamiento)) casos_rucs <- as.character(casos_fraccionamiento$RUC)
}
# --- Comprobar que existe la columna 'Contratista' en datos ---
if (!"Contratista" %in% names(datos)) stop("La columna 'Contratista' no existe en 'datos'. Revisa colnames(datos).")
# --- Crear Fecha_Emision (intentar varios formatos) ---
datos <- datos %>%
mutate(
Fecha_Emision = parse_date_time(
`Fecha de suscripci√≥n del contrato`,
orders = c("Y-m-d", "d/m/Y", "m/d/Y", "d-%m-%Y", "Y/%m/%d"),
exact = FALSE
) %>% as.Date()
)
# --- Limpiar monto y crear variables ---
datos_modelo <- datos %>%
mutate(
# limpiar texto de Monto y convertir a num√©rico (quita caracteres no num√©ricos)
Monto_limpio = as.numeric(gsub(",", "", gsub("[^0-9.\\-]", "", as.character(Monto)))),
# marcar sospechoso usando vectores seguros
Es_Sospechoso = as.integer(Contratista %in% score_rucs | Contratista %in% casos_rucs),
# variables temporales / derivadas
Mes = lubridate::month(Fecha_Emision),
Es_Fin_A√±o = ifelse(!is.na(Mes) & Mes >= 11, 1L, 0L),
Dias_Desde_Inicio = as.numeric(Fecha_Emision - min(Fecha_Emision, na.rm = TRUE)),
Monto_Normalizado = ifelse(!is.na(Monto_limpio), as.numeric(scale(Monto_limpio)[,1]), NA_real_),
Participacion_Mercado = 0  # valor temporal
)
# --- Opcional: ver resumen r√°pido ---
cat("Filas originales:", nrow(datos), "\n")
cat("Filas para modelo:", nrow(datos_modelo), "\n")
cat("Total Es_Sospechoso == 1:", sum(datos_modelo$Es_Sospechoso, na.rm = TRUE), "\n")
# --- (Opcional) filtrar filas con Es_Sospechoso NA (si quieres) ---
# datos_modelo <- datos_modelo %>% filter(!is.na(Es_Sospechoso))
# --- Entrenar modelo (si hay suficientes filas y clases) ---
# Verificar que haya al menos una observaci√≥n de cada clase
if (nrow(datos_modelo) > 10 && length(unique(na.omit(datos_modelo$Es_Sospechoso))) > 1) {
set.seed(123)
modelo_rf <- randomForest(
factor(Es_Sospechoso) ~ Monto_Normalizado + Mes + Es_Fin_A√±o + Dias_Desde_Inicio + Participacion_Mercado,
data = datos_modelo,
ntree = 500,
importance = TRUE
)
varImpPlot(modelo_rf)
print(importance(modelo_rf))
} else {
message("No se entrena el modelo: no hay suficientes filas o falta diversidad en Es_Sospechoso.")
}
# NUEVO: Tests estad√≠sticos
library(stats)
# Test de diferencia antes/despu√©s cambio de gesti√≥n
wilcox.test(
datos %>% filter(A√±o < 2023) %>% pull(Monto_limpio),
datos %>% filter(A√±o >= 2023) %>% pull(Monto_limpio)
)
# NUEVO: Tests estad√≠sticos
library(stats)
# Test de diferencia antes/despu√©s cambio de gesti√≥n
wilcox.test(
datos %>% filter(A√±o < 2023) %>% pull(Monto_limpio),
datos %>% filter(A√±o >= 2023) %>% pull(Monto_limpio)
)
# NUEVO: Tests estad√≠sticos
library(stats)
# Test de diferencia antes/despu√©s cambio de gesti√≥n
wilcox.test(
datos %>% filter(A√±o < 2023) %>% pull(Monto_limpio),
datos %>% filter(A√±o >= 2023) %>% pull(Monto_limpio)
)
library(dplyr)
library(stats)
library(lubridate)
library(benford.analysis)
# Asegurar que la columna de fecha sea tipo Date
datos <- datos %>%
mutate(
Fecha = as.Date(`Fecha de suscripci√≥n del contrato`, format = "%Y-%m-%d"),
A√±o = year(Fecha)
)
# Test de diferencia antes/despu√©s del a√±o 2023
wilcox.test(
datos %>% filter(A√±o < 2023) %>% pull(Monto),
datos %>% filter(A√±o >= 2023) %>% pull(Monto)
)
# ===============================================
# Tests estad√≠sticos (versi√≥n corregida y segura)
# ===============================================
library(dplyr)
library(lubridate)
library(stats)
library(benford.analysis)
# Asegurar que la columna de fecha sea tipo Date y crear columna A√±o
datos <- datos %>%
mutate(
Fecha = as.Date(`Fecha de suscripci√≥n del contrato`, format = "%Y-%m-%d"),
A√±o = year(Fecha)
)
# Verificar cu√°ntos registros hay por a√±o
print(table(datos$A√±o))
# Crear subconjuntos, eliminando NAs
antes_2023 <- datos %>% filter(A√±o < 2023 & !is.na(Monto)) %>% pull(Monto)
desde_2023 <- datos %>% filter(A√±o >= 2023 & !is.na(Monto)) %>% pull(Monto)
# Solo ejecutar el test si ambas muestras tienen datos
if (length(antes_2023) > 1 && length(desde_2023) > 1) {
resultado_wilcox <- wilcox.test(antes_2023, desde_2023)
print(resultado_wilcox)
} else {
cat("‚ö†Ô∏è No hay suficientes datos v√°lidos en uno o ambos grupos para realizar el test de Wilcoxon.\n")
cat("Registros antes de 2023:", length(antes_2023), "\n")
cat("Registros desde 2023:", length(desde_2023), "\n")
}
# Test de Benford
benford_test <- benford(datos$Monto, number.of.digits = 1)
plot(benford_test)
cat("\nTest de Benford - Desviaci√≥n significativa indica posible manipulaci√≥n de cifras\n")
print(benford_test)
library(dplyr)
library(ggplot2)
library(scales)
# Filtrar √≥rdenes anuladas
anuladas <- datos %>%
filter(Estado == "Anulada")
# Estad√≠sticas b√°sicas
total_ordenes <- nrow(datos)
total_anuladas <- nrow(anuladas)
porcentaje_anuladas <- round((total_anuladas / total_ordenes) * 100, 2)
# Si hay m√°s de una orden anulada
if (nrow(anuladas) > 1) {
# Agrupar y contar por proveedor (puedes cambiar el nombre de columna)
resumen <- anuladas %>%
group_by(Proveedor) %>%
summarise(Cantidad = n())
p2 <- ggplot(resumen, aes(x = reorder(Proveedor, Cantidad),
y = Cantidad, fill = Proveedor)) +
geom_col(alpha = 0.8) +
geom_text(aes(label = Cantidad), hjust = -0.1, fontface = "bold") +
coord_flip() +
labs(title = "Cantidad de √ìrdenes Anuladas por Proveedor",
x = "Proveedor", y = "Cantidad de √ìrdenes") +
scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold"))
print(p2)
} else if (total_anuladas > 0) {
Anuladas1 <- ggplot(anuladas, aes(x = Proveedor, y = Monto_limpio, fill = Proveedor)) +
geom_col(alpha = 0.8) +
geom_text(aes(label = paste0("S/. ", comma(Monto_limpio))),
vjust = -0.3, fontface = "bold") +
labs(title = paste0("√ìrdenes Anuladas (", total_anuladas, " casos)"),
x = "Proveedor", y = "Monto (S/.)") +
scale_y_continuous(labels = function(x) paste0("S/. ", comma(x)),
expand = expansion(mult = c(0, 0.15))) +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold"))
ggsave("Anuladas1.png", plot = Anuladas1, width = 8, height = 6, dpi = 300)
print(Anuladas1)
}
# Primero calcular el total de datos v√°lidos
datos_validos <- datos %>%
filter(!is.na(Estado_Registro) & Estado_Registro != "")
library(dplyr)
library(ggplot2)
# 1Ô∏è‚É£ Verificar si la columna existe
if (!"Estado_Registro" %in% colnames(datos)) {
message("‚ö†Ô∏è La columna 'Estado_Registro' no existe. Se usar√° 'Estado' en su lugar.")
datos <- datos %>% rename(Estado_Registro = Estado)
}
# 2Ô∏è‚É£ Filtrar datos v√°lidos
datos_validos <- datos %>%
filter(!is.na(Estado_Registro) & Estado_Registro != "")
total_ordenes <- nrow(datos_validos)
# 3Ô∏è‚É£ Si hay datos, calcular el cumplimiento
if (total_ordenes > 0) {
cumplimiento <- datos_validos %>%
mutate(
Registro_Oportuno = ifelse(Estado_Registro == "Registrado dentro de plazo", "S√≠", "No")
) %>%
group_by(Registro_Oportuno) %>%
summarise(Cantidad = n(), .groups = "drop") %>%
mutate(Porcentaje = Cantidad / total_ordenes * 100)
# 4Ô∏è‚É£ Crear el gr√°fico circular
Ordenes_validas <- ggplot(cumplimiento, aes(x = "", y = Porcentaje, fill = Registro_Oportuno)) +
geom_bar(stat = "identity", width = 1) +
coord_polar("y") +
geom_text(
aes(label = paste0(round(Porcentaje, 1), "%\n(", Cantidad, " √≥rdenes)")),
position = position_stack(vjust = 0.5),
color = "white", fontface = "bold", size = 4
) +
labs(
title = "Cumplimiento de Plazos de Registro de √ìrdenes",
subtitle = paste0("Total analizado: ", total_ordenes, " √≥rdenes"),
fill = "Registro Oportuno"
) +
scale_fill_manual(
values = c("No" = "#e74c3c", "S√≠" = "#27ae60"),
labels = c("No" = "Fuera de Plazo", "S√≠" = "Dentro de Plazo")
) +
theme_void() +
theme(
plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
plot.subtitle = element_text(size = 11, color = "gray60", hjust = 0.5),
legend.position = "bottom",
legend.title = element_text(face = "bold"),
legend.text = element_text(size = 11)
)
print(Ordenes_validas)
# Guardar imagen
ggsave("Ordenes_validas.png", plot = Ordenes_validas,
width = 8, height = 6, dpi = 300)
} else {
message("‚ö†Ô∏è No hay datos v√°lidos para generar el gr√°fico.")
}
library(dplyr)
library(ggplot2)
library(scales)
# Filtrar √≥rdenes anuladas
anuladas <- datos %>%
filter(Estado == "Anulada")
# Primero calcular el total de datos v√°lidos
datos_validos <- datos %>%
filter(!is.na(Estado_Registro) & Estado_Registro != "")
total_ordenes <- nrow(datos_validos)
cumplimiento <- datos_validos %>%
mutate(
Registro_Oportuno = ifelse(Estado_Registro == "Registrado dentro de plazo", "S√≠", "No")
) %>%
group_by(Registro_Oportuno) %>%
summarise(Cantidad = n()) %>%
mutate(Porcentaje = Cantidad / total_ordenes * 100)  # Usar total_ordenes, no nrow(datos)
Ordenes_validas = ggplot(cumplimiento, aes(x = "", y = Porcentaje, fill = Registro_Oportuno)) +
geom_bar(stat = "identity", width = 1) +
coord_polar("y") +
geom_text(aes(label = paste0(round(Porcentaje, 1), "%\n(", Cantidad, " √≥rdenes)")),
position = position_stack(vjust = 0.5),
color = "white", fontface = "bold", size = 4) +
labs(
title = "Cumplimiento de Plazos de Registro de √ìrdenes",
subtitle = paste0("Total analizado: ", total_ordenes, " √≥rdenes"),
fill = "Registro Oportuno"
) +
scale_fill_manual(
values = c("No" = "#e74c3c", "S√≠" = "#27ae60"),  # Rojo para No, Verde para S√≠
labels = c("No" = "Fuera de Plazo", "S√≠" = "Dentro de Plazo")
) +
theme_void() +
theme(
plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
plot.subtitle = element_text(size = 11, color = "gray60", hjust = 0.5),
legend.position = "bottom",
legend.title = element_text(face = "bold"),
legend.text = element_text(size = 11)
)
Ordenes_validas
ggsave("Ordenes_validas.png", plot = Ordenes_validas,
width = 8, height = 6, dpi = 300)
library(dplyr)
library(ggplot2)
library(scales)
# Filtrar √≥rdenes anuladas
anuladas <- datos %>%
filter(Estado == "Anulada")
View(anuladas)
# Cargar librer√≠as necesarias
library(readxl)
library(dplyr)
library(ggplot2)
library(lubridate)
library(stringr)
library(scales)
library(tidyr)
library(forcats)
library(ggrepel)
library(patchwork)
# 1. LIMPIEZA Y PREPARACI√ìN DE DATOS
# Cargar los datos
datos <- read_excel("DRTC-H.xlsx")
# Corregir nombres de columnas (quitar acentos y caracteres especiales)
datos <- datos %>%
rename_with(~ c("N", "Entidad", "Tipo_Orden", "Numero_Orden", "Tipo_Contratacion",
"Fecha_Emision", "Fecha_Compromiso", "Monto", "RUC",
