```{r}
# Cargar librerías necesarias
library(readxl)
library(dplyr)
library(ggplot2)
library(lubridate)
library(stringr)
library(scales)
library(tidyr)
library(forcats)
library(ggrepel)
library(patchwork)


# 1. LIMPIEZA Y PREPARACIÓN DE DATOS


# Cargar los datos
datos <- read_excel("DRTC-H.xlsx")


# Corregir nombres de columnas (quitar acentos y caracteres especiales)
datos <- datos %>%
  rename_with(~ c("N", "Entidad", "Tipo_Orden", "Numero_Orden", "Tipo_Contratacion",
                  "Fecha_Emision", "Fecha_Compromiso", "Monto", "RUC", 
                  "Razon_Social", "Estado", "Estado_Registro", "Observaciones")[seq_along(.)])


# Convertir fechas a formato Date
datos <- datos %>%
  mutate(
    Fecha_Emision = as.Date(Fecha_Emision),
    Fecha_Compromiso = as.Date(Fecha_Compromiso)
  )


# Convertir montos a numérico
datos <- datos %>%
  mutate(
    Monto_limpio = as.numeric(gsub(",", "", gsub("^S/\\. ", "", Monto)))
  )



# Eliminar filas con montos nulos si las hay
datos <- datos %>% filter(!is.na(Monto_limpio))
datos <- datos %>%
  mutate(Nombre_Corto = ifelse(nchar(Razon_Social) > 15, 
                               paste0(substr(Razon_Social, 1, 12), "..."), 
                               Razon_Social))



```

```{r}
total_general <- sum(datos$Monto_limpio)

# Luego calculamos el top 5 y los porcentajes
top5_proveedores <- datos %>%
  group_by(Razon_Social) %>%
  summarise(Monto_Total = sum(Monto_limpio)) %>%
  arrange(desc(Monto_Total)) %>%
  mutate(Porcentaje = Monto_Total / total_general * 100) %>%  
  slice_head(n = 5)

Top5 = ggplot(top5_proveedores, aes(x = reorder(Razon_Social, Monto_Total), y = Monto_Total, fill = Razon_Social)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  geom_text(aes(label = paste0(round(Porcentaje, 1), "%")), hjust = -0.2) +
  labs(title = "Top 5 Proveedores por Monto y % del Total",
       x = "Proveedor", y = "Monto Total (S/.)") +
  scale_y_continuous(labels = comma) +
  theme_minimal() +
  theme(legend.position = "none")

Top5
ggsave("Top5.png", plot = Top5,
width = 8, height = 6, dpi = 300)

```

```{r}
# Preparar datos para curva de Pareto
pareto <- datos %>%
  group_by(Razon_Social) %>%
  summarise(Monto_Total = sum(Monto_limpio)) %>%
  arrange(desc(Monto_Total)) %>%
  mutate(
    Acumulado = cumsum(Monto_Total),
    Porcentaje_Acum = Acumulado / sum(Monto_Total) * 100,
    Proveedor_ID = row_number()
  )

# Gráfico de Pareto corregido
Pareto = ggplot(pareto, aes(x = Proveedor_ID)) +
  geom_bar(aes(y = Monto_Total), stat = "identity", fill = "steelblue", alpha = 0.7) +
  geom_line(aes(y = Acumulado * max(Monto_Total) / max(Acumulado)), 
            color = "red", linewidth = 1) +
  geom_point(aes(y = Acumulado * max(Monto_Total) / max(Acumulado)), 
             color = "red", size = 2) +
  scale_y_continuous(
    name = "Monto por Proveedor (S/.)",
    labels = comma,
    sec.axis = sec_axis(
      ~ . / max(pareto$Monto_Total) * 100, 
      name = "Porcentaje Acumulado (%)",
      labels = function(x) paste0(round(x, 1), "%")
    )
  ) +
  labs(
    title = "Curva de Pareto de Proveedores",
    x = "Proveedores (ordenados por monto)",
    caption = "Las barras muestran el monto individual, la línea roja muestra el acumulado"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    axis.title = element_text(size = 12)
  )

Pareto
ggsave("Pareto.png", plot = Pareto,
width = 8, height = 6, dpi = 300)

```

```{r}

proveedores <- datos %>%
  group_by(Nombre_Corto) %>%
  summarise(
    Ordenes = n(),
    Monto_Total = sum(Monto_limpio)
  ) %>%
  arrange(desc(Ordenes))

Proveedores = ggplot(proveedores %>% filter(Ordenes > 1), 
       aes(x = reorder(Nombre_Corto, Ordenes), y = Ordenes, fill = Ordenes)) +
  geom_col() +
  geom_text(aes(label = paste0(Ordenes, " ord. | S/ ", comma(round(Monto_Total,0)))),
            hjust = -0.1, size = 3.2) +
  coord_flip() +
  labs(title = "Proveedores con más de una orden en el mes",
       x = "Proveedor", y = "Cantidad de Órdenes") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  scale_y_continuous(expand = expansion(mult = c(0,0.15))) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.y = element_text(size = 9),
    plot.margin = margin(5.5, 15, 5.5, 5.5, "pt")
  )

Proveedores
ggsave("Proveedores.png", plot = Proveedores,
width = 8, height = 6, dpi = 300)
```

```{r}
# Clasificación por tipo de RUC
datos <- datos %>%
  mutate(Tipo_Proveedor = case_when(
    str_starts(RUC, "10") ~ "Persona Natural",
    str_starts(RUC, "20") ~ "Persona Jurídica",
    TRUE ~ "Otro"
  ))

# Distribución de montos por tipo de proveedor
total_general <- sum(datos$Monto_limpio)

dist_tipo <- datos %>%
  group_by(Tipo_Proveedor) %>%
  summarise(Monto_Total = sum(Monto_limpio)) %>%
  mutate(
    Porcentaje = Monto_Total / total_general * 100,
    Etiqueta = paste0("S/ ", comma(round(Monto_Total,0)), 
                      " (", round(Porcentaje,1), "%)")
  )


# Gráfico circular mejorado con montos y porcentajes
Tipo_Prov = ggplot(dist_tipo, aes(x = "", y = Monto_Total, fill = Tipo_Proveedor)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = Etiqueta), 
            position = position_stack(vjust = 0.5),
            color = "white", fontface = "bold", size = 4.2) +
  labs(title = "Distribución del Gasto por Tipo de Proveedor",
       fill = "Tipo de Proveedor") +
  scale_fill_manual(values = c("Persona Natural" = "#3498db", 
                               "Persona Jurídica" = "#e74c3c", 
                               "Otro" = "#95a5a6")) +
  theme_void() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "bottom",
    legend.title = element_text(face = "bold")
  )

Tipo_Prov
ggsave("Tipo_Prov.png", plot = Tipo_Prov,
width = 8, height = 6, dpi = 300)

```

```{r}
# Órdenes por día (filtrando fechas válidas)
ordenes_por_dia <- datos %>%
  filter(!is.na(Fecha_Emision)) %>%  # Eliminar fechas nulas
  group_by(Fecha_Emision) %>%
  summarise(
    Ordenes = n(),
    Monto_Total = sum(Monto_limpio)
  ) %>%
  arrange(Fecha_Emision)  # Ordenar por fecha

# Calcular factor de escalado dinámico
factor_escala <- max(ordenes_por_dia$Ordenes) / max(ordenes_por_dia$Monto_Total)

# Gráfico combinado: barras para cantidad, línea para monto
Ordenes_dia = ggplot(ordenes_por_dia, aes(x = Fecha_Emision)) +
  geom_col(aes(y = Ordenes), fill = "steelblue", alpha = 0.7) +
  geom_line(aes(y = Monto_Total * factor_escala), color = "red", linewidth = 1) +
  geom_point(aes(y = Monto_Total * factor_escala), color = "red", size = 2) +
  scale_x_date(date_breaks = "1 week", date_labels = "%d/%m") +  # Formato de fechas
  scale_y_continuous(
    name = "Número de Órdenes",
    sec.axis = sec_axis(
      ~ . / factor_escala, 
      name = "Monto Total (S/.)", 
      labels = function(x) paste0("S/. ", comma(x))
    )
  ) +
  labs(
    title = "Órdenes y Monto Total por Día",
    subtitle = "Barras azules: cantidad de órdenes | Línea roja: monto total",
    x = "Fecha de Emisión",
    caption = "Nota: Los dos ejes tienen escalas diferentes"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11, color = "gray60"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )

Ordenes_dia
ggsave("Ordenes_dia.png", plot = Ordenes_dia,
width = 8, height = 6, dpi = 300)
```

```{r}
# Crear semana del mes (con filtro de fechas válidas)
datos <- datos %>%
  filter(!is.na(Fecha_Emision)) %>%  # Filtrar fechas nulas
  mutate(Semana = paste0("Semana ", ceiling(day(Fecha_Emision) / 7)))

# Resumen por semana
resumen_semana <- datos %>%
  group_by(Semana) %>%
  summarise(
    Ordenes = n(),
    Monto_Total = sum(Monto_limpio)
  ) %>%
  # Ordenar semanas correctamente
  mutate(Semana_num = as.numeric(str_extract(Semana, "\\d+"))) %>%
  arrange(Semana_num) %>%
  select(-Semana_num)

print(resumen_semana)


Total_Semana = ggplot(resumen_semana, aes(x = factor(Semana, levels = paste0("Semana ", 1:5)), 
                           y = Monto_Total, fill = Semana)) +
  geom_col(alpha = 0.8) +
  geom_text(aes(label = paste0("S/. ", comma(Monto_Total))), 
            vjust = -0.3, fontface = "bold", size = 3.5) +
  geom_text(aes(label = paste0("(", Ordenes, " órdenes)")), 
            vjust = 1.5, color = "white", fontface = "bold", size = 3) +
  labs(title = "Monto Total por Semana",
       subtitle = "Muestra monto total y cantidad de órdenes por semana",
       x = "Semana", y = "Monto Total (S/.)") +
  scale_y_continuous(labels = function(x) paste0("S/. ", comma(x)),
                    expand = expansion(mult = c(0, 0.1))) +  # Más espacio arriba para etiquetas
  scale_fill_brewer(type = "qual", palette = "Set2") +  # Colores más atractivos
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11, color = "gray60"),
    axis.text.x = element_text(size = 11),
    axis.title = element_text(size = 12)
  )

Total_Semana
ggsave("Total_Semana.png", plot = Total_Semana,
width = 8, height = 6, dpi = 300)
```

```{r}
# Calcular diferencia en días (con filtros y validaciones)
datos <- datos %>%
  filter(!is.na(Fecha_Emision) & !is.na(Fecha_Compromiso)) %>%  # Filtrar fechas nulas
  mutate(Dias_Procesamiento = as.numeric(difftime(Fecha_Compromiso, Fecha_Emision, units = "days"))) %>%
  # Filtrar valores extremos o negativos (opcional, según tu contexto)
  filter(Dias_Procesamiento >= 0 & Dias_Procesamiento <= 365)  # Máximo 1 año


# Histograma mejorado
Proceso_entre_D_S = ggplot(datos, aes(x = Dias_Procesamiento)) +
  geom_histogram(binwidth = 1, fill = "orange", color = "black", alpha = 0.7) +
  geom_vline(aes(xintercept = mean(Dias_Procesamiento, na.rm = TRUE)), 
             color = "red", linetype = "dashed", linewidth = 1) +
  geom_vline(aes(xintercept = median(Dias_Procesamiento, na.rm = TRUE)), 
             color = "blue", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Distribución del Tiempo de Procesamiento de Órdenes",
    subtitle = "Línea roja: promedio | Línea azul: mediana",
    x = "Días entre Emisión y Compromiso", 
    y = "Cantidad de Órdenes",
    caption = paste0("n = ", nrow(datos), " órdenes con fechas válidas")
  ) +
  scale_x_continuous(breaks = seq(0, max(datos$Dias_Procesamiento, na.rm = TRUE), by = 5)) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11, color = "gray60"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

Proceso_entre_D_S
ggsave("Proceso_entre_D_S.png", plot = Proceso_entre_D_S,
width = 8, height = 6, dpi = 300)
```

```{r}
# Scatterplot monto vs tiempo
Monto_Tiempo = ggplot(datos, aes(x = Dias_Procesamiento, y = Monto_limpio)) +
  geom_jitter(alpha = 0.6, color = "steelblue") +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "Relación entre Tiempo de Procesamiento y Monto",
       x = "Días de Procesamiento", y = "Monto (S/.)") +
  scale_y_continuous(labels = comma) +
  theme_minimal()

Monto_Tiempo
ggsave("Monto_Tiempo.png", plot = Monto_Tiempo,
width = 8, height = 6, dpi = 300)
```

```{r}
# Primero calcular el total de datos válidos
datos_validos <- datos %>% 
  filter(!is.na(Estado_Registro) & Estado_Registro != "")

total_ordenes <- nrow(datos_validos)

cumplimiento <- datos_validos %>%
  mutate(
    Registro_Oportuno = ifelse(Estado_Registro == "Registrado dentro de plazo", "Sí", "No")
  ) %>%
  group_by(Registro_Oportuno) %>%
  summarise(Cantidad = n()) %>%
  mutate(Porcentaje = Cantidad / total_ordenes * 100)  # Usar total_ordenes, no nrow(datos)


Ordenes_validas = ggplot(cumplimiento, aes(x = "", y = Porcentaje, fill = Registro_Oportuno)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = paste0(round(Porcentaje, 1), "%\n(", Cantidad, " órdenes)")),
            position = position_stack(vjust = 0.5),
            color = "white", fontface = "bold", size = 4) +
  labs(
    title = "Cumplimiento de Plazos de Registro de Órdenes",
    subtitle = paste0("Total analizado: ", total_ordenes, " órdenes"),
    fill = "Registro Oportuno"
  ) +
  scale_fill_manual(
    values = c("No" = "#e74c3c", "Sí" = "#27ae60"),  # Rojo para No, Verde para Sí
    labels = c("No" = "Fuera de Plazo", "Sí" = "Dentro de Plazo")
  ) +
  theme_void() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 11, color = "gray60", hjust = 0.5),
    legend.position = "bottom",
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 11)
  )

Ordenes_validas
ggsave("Ordenes_validas.png", plot = Ordenes_validas,
width = 8, height = 6, dpi = 300)

```

```{r}
library(dplyr)
library(ggplot2)
library(scales)

# Filtrar órdenes anuladas
anuladas <- datos %>%
  filter(Estado == "Anulada")

# Estadísticas básicas
total_ordenes <- nrow(datos)
total_anuladas <- nrow(anuladas)
porcentaje_anuladas <- round((total_anuladas / total_ordenes) * 100, 2)

# Si hay más de una orden anulada
if (nrow(anuladas) > 1) {
  
  # Agrupar y contar por proveedor (puedes cambiar el nombre de columna)
  resumen <- anuladas %>%
    group_by(Proveedor) %>%
    summarise(Cantidad = n())
  
  p2 <- ggplot(resumen, aes(x = reorder(Proveedor, Cantidad), 
                            y = Cantidad, fill = Proveedor)) +
    geom_col(alpha = 0.8) +
    geom_text(aes(label = Cantidad), hjust = -0.1, fontface = "bold") +
    coord_flip() +
    labs(title = "Cantidad de Órdenes Anuladas por Proveedor",
         x = "Proveedor", y = "Cantidad de Órdenes") +
    scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(face = "bold"))
  
  print(p2)
  
} else if (total_anuladas > 0) {
  
  Anuladas1 <- ggplot(anuladas, aes(x = Proveedor, y = Monto_limpio, fill = Proveedor)) +
    geom_col(alpha = 0.8) +
    geom_text(aes(label = paste0("S/. ", comma(Monto_limpio))), 
              vjust = -0.3, fontface = "bold") +
    labs(title = paste0("Órdenes Anuladas (", total_anuladas, " casos)"),
         x = "Proveedor", y = "Monto (S/.)") +
    scale_y_continuous(labels = function(x) paste0("S/. ", comma(x)),
                       expand = expansion(mult = c(0, 0.15))) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(face = "bold"))
  
  ggsave("Anuladas1.png", plot = Anuladas1, width = 8, height = 6, dpi = 300)
  print(Anuladas1)
}

```

```{r}
# Posible fraccionamiento en personas naturales
fracc_naturales <- datos %>%
  filter(Tipo_Proveedor == "Persona Natural") %>%
  group_by(Razon_Social, RUC) %>%
  summarise(
    Ordenes = n(),
    Monto_Total = sum(Monto_limpio),
    Monto_Max = max(Monto_limpio),
    .groups = "drop"
  ) %>%
  filter(Ordenes > 1 & Monto_Max < 39600) %>% # límite 8 UIT
  arrange(desc(Monto_Total))

print(fracc_naturales)

# Gráfico mejorado: cantidad de órdenes + monto total
if(nrow(fracc_naturales) > 0){
  fracc_naturales = ggplot(fracc_naturales, 
         aes(x = reorder(Razon_Social, Monto_Total), 
             y = Monto_Total, fill = Ordenes)) +
    geom_col() +
    geom_text(aes(label = paste0("S/ ", comma(round(Monto_Total,0)),
                                 " (", Ordenes, " ord.)")),
              hjust = -0.1, size = 3.5) +
    coord_flip() +
    labs(title = "Personas Naturales con Múltiples Órdenes < 8 UIT (Posible Fraccionamiento)",
         x = "Proveedor", y = "Monto Total (S/.)") +
    scale_y_continuous(labels = comma, expand = expansion(mult = c(0,0.15))) +
    theme_minimal() +
    theme(legend.position = "none")
  ggsave("fracc_naturales.png", plot = fracc_naturales,
width = 8, height = 6, dpi = 300)
  fracc_naturales
}



```

```{r}
# ANÁLISIS FORENSE DE PROVEEDORES
# --------------------------------
# Después de crear 'top5_proveedores' y 'pareto', agregue esto:

# A) Cruzar con RUC y Dirección de Caminos
proveedores_analisis <- datos %>%
  group_by(Razon_Social, RUC) %>%
  summarise(
    Ordenes = n(),
    Monto_Total = sum(Monto_limpio),
    .groups = 'drop'
  ) %>%
  arrange(desc(Monto_Total))

# BANDERA ROJA 1: ¿Algún proveedor principal es "HVIAL INGENIERIA TOTAL S.A.C."?
# (La empresa del Director Regional, Imer Haro)
print(proveedores_analisis %>% filter(str_detect(Razon_Social, "INGENIERIA")))

# BANDERA ROJA 2: Proveedores con múltiples órdenes de bajo monto (posible fraccionamiento)
# Esto ya lo tiene, pero hay que enfocarlo en obras.
proveedores_sospechosos <- datos %>%
  filter(Tipo_Contratacion %in% c("Contratación Directa", "Adjudicación Simplificada")) %>%
  group_by(Razon_Social, RUC) %>%
  summarise(
    Ordenes = n(),
    Monto_Total = sum(Monto_limpio),
    Monto_Promedio = mean(Monto_limpio),
    .groups = 'drop'
  ) %>%
  filter(Ordenes > 3 & Monto_Promedio < 8000) %>% # Ajuste umbral según el presupuesto
  arrange(desc(Ordenes))

print(proveedores_sospechosos)
```


```{r}
# AGREGAR AL INICIO:
# ========================================
# MARCO CONCEPTUAL Y DEFINICIONES
# ========================================

cat("DEFINICIONES OPERACIONALES:\n")
cat("---------------------------\n")
cat("• Fraccionamiento: División artificial de contratos para evadir límites legales\n")
cat("• IHH > 2500: Mercado altamente concentrado (posible colusión)\n")
cat("• Empresa fantasma: RUC nuevo + contrato grande + actividad corta\n")
cat("• Sobreprecio: Precio >150% del límite superior del IQR\n\n")

# Agregar contexto legal
normativa <- data.frame(
  Ley = c("Ley 30225", "Ley 27444", "Ley 28716"),
  Tema = c("Contrataciones del Estado", 
           "Procedimiento Administrativo General",
           "Ley de Control Interno"),
  Umbral_Relevante = c("8 UIT para Adjudicación Simplificada",
                       "N/A",
                       "Auditoría obligatoria")
)

print(normativa)
```


```{r}
library(tidytext)
library(wordcloud)
library(tm)

# Si tienes campo de observaciones
if("Observaciones" %in% names(datos)) {
  
  # Tokenización
  palabras_observaciones <- datos %>%
    filter(!is.na(Observaciones), Observaciones != "") %>%
    unnest_tokens(word, Observaciones) %>%
    anti_join(stop_words) %>%
    count(word, sort = TRUE)
  
  # Nube de palabras
  wordcloud(palabras_observaciones$word, 
            palabras_observaciones$n,
            max.words = 100,
            colors = brewer.pal(8, "Dark2"))
  
  # Bigramas sospechosos
  bigramas <- datos %>%
    filter(!is.na(Observaciones)) %>%
    unnest_tokens(bigram, Observaciones, token = "ngrams", n = 2) %>%
    count(bigram, sort = TRUE) %>%
    head(20)
  
  print(bigramas)
}
```

```{r}
library(igraph)
library(ggraph)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(scales)

# ================================================
# 1️⃣ Crear la red de proveedores con patrones similares
# ================================================
# Convertimos RUC a character desde el inicio para evitar incompatibilidades
red_temporal <- datos %>%
  mutate(RUC = as.character(RUC)) %>%
  select(RUC, Fecha_Emision, Monto_limpio) %>%
  mutate(Semana = floor_date(Fecha_Emision, "week")) %>%
  group_by(RUC, Semana) %>%
  summarise(Monto = sum(Monto_limpio, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = Semana, values_from = Monto, values_fill = 0)

matriz_proveedores <- as.matrix(red_temporal[,-1])
rownames(matriz_proveedores) <- red_temporal$RUC

# Correlación entre patrones de gasto
correlacion_proveedores <- cor(t(matriz_proveedores), use = "pairwise.complete.obs")

# Crear red con correlaciones > 0.7
adj_mat <- (correlacion_proveedores > 0.7) * correlacion_proveedores
diag(adj_mat) <- 0
red_sospechosa <- graph_from_adjacency_matrix(adj_mat, mode = "undirected", weighted = TRUE, diag = FALSE)

# ================================================
# 2️⃣ Calcular métricas y seleccionar el top 20
# ================================================
# Grado (número de conexiones)
grados <- degree(red_sospechosa)

# Fuerza total (suma de correlaciones)
fuerza_total <- strength(red_sospechosa)

# Crear data frame con métricas (asegurando character)
metricas <- data.frame(
  Proveedor = as.character(names(grados)),
  Grado = as.integer(grados),
  Fuerza = as.numeric(fuerza_total),
  stringsAsFactors = FALSE
) %>%
  arrange(desc(Fuerza)) %>%
  slice_head(n = 20)

# ================================================
# 3️⃣ Vincular nombres de proveedores (si existen)
# ================================================
# Detectar columna de nombre en 'datos'
col_nombres <- intersect(names(datos), c("Nombre_Proveedor", "Razon_Social", "Proveedor_Nombre"))

if (length(col_nombres) > 0) {
  # Aseguramos que RUC sea character en la tabla de nombres
  nombres_unicos <- datos %>%
    mutate(RUC = as.character(RUC)) %>%
    select(RUC, all_of(col_nombres[1])) %>%
    distinct()
  
  # Convertir Proveedor a character antes de hacer join
  metricas <- metricas %>%
    mutate(Proveedor = as.character(Proveedor)) %>%
    left_join(nombres_unicos, by = c("Proveedor" = "RUC")) %>%
    mutate(
      # Si el nombre viene NA, dejaremos solo el RUC
      !!paste0("Etiqueta") := ifelse(
        is.na(.[[col_nombres[1]]]),
        paste0("(", Proveedor, ")"),
        paste0(.[[col_nombres[1]]], "\n(", Proveedor, ")")
      )
    )
} else {
  metricas <- metricas %>%
    mutate(Etiqueta = paste0("Proveedor ", row_number(), "\n(", Proveedor, ")"))
}

# ================================================
# 4️⃣ Subgrafo con los top 20 y pasar atributos
# ================================================
# Aseguramos que los vértices a inducir existan en la red original
v_presentes <- intersect(metricas$Proveedor, V(red_sospechosa)$name)
sub_red <- induced_subgraph(red_sospechosa, vids = v_presentes)

# Asignar la fuerza como atributo de vértice en el subgrafo (para usar en aes)
V(sub_red)$Fuerza <- fuerza_total[V(sub_red)$name]
# También asignar etiqueta (si metricas no tiene alguno por NA, crear fallback)
labels_map <- metricas %>% filter(Proveedor %in% V(sub_red)$name) %>% select(Proveedor, Etiqueta)
V(sub_red)$Etiqueta <- labels_map$Etiqueta[match(V(sub_red)$name, labels_map$Proveedor)]
V(sub_red)$Etiqueta[is.na(V(sub_red)$Etiqueta)] <- paste0("(", V(sub_red)$name[is.na(V(sub_red)$Etiqueta)], ")")

# ================================================
# 5️⃣ Visualización elegante con ggraph (usa atributos del subgrafo)
# ================================================
set.seed(123)

ggraph(sub_red, layout = "fr") +
  geom_edge_link(aes(width = weight, alpha = weight), color = "#5DADE2") +
  geom_node_point(aes(size = Fuerza), color = "#E74C3C") +
  geom_node_text(aes(label = Etiqueta), repel = TRUE, size = 3, color = "black", fontface = "bold") +
  scale_edge_width_continuous(range = c(0.2, 2), guide = "none") +
  scale_size_continuous(range = c(4, 10)) +
  theme_void() +
  labs(
    title = "🔥 Top 20 Proveedores con Patrones de Gasto Similares",
    subtitle = "Tamaño del nodo = Fuerza total de correlación | Color de líneas = nivel de similitud",
    caption = "Fuente: Análisis de correlación temporal entre proveedores"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16, color = "#1A5276"),
    plot.subtitle = element_text(size = 11, color = "#2E4053"),
    plot.caption = element_text(size = 8, color = "#7F8C8D")
  )

# ================================================
# 6️⃣ Mostrar tabla ordenada con los puntajes (incluye nombre si existe)
# ================================================
tabla_final <- metricas %>%
  arrange(desc(Fuerza)) %>%
  mutate(Rank = row_number()) %>%
  select(Rank, everything())

tabla_final


```

```{r}
library(dplyr)
library(lubridate)
library(randomForest)
library(caret)
library(ggplot2)

# --- Preparar vectores seguros desde score_integral y casos_fraccionamiento ---
# Si los objetos no existen o no tienen las columnas esperadas, quedan vacíos.
score_rucs <- character(0)
if (exists("score_integral")) {
  if ("Contratista" %in% names(score_integral)) score_rucs <- as.character(score_integral$Contratista)
  else if ("RUC" %in% names(score_integral)) score_rucs <- as.character(score_integral$RUC)
}

casos_rucs <- character(0)
if (exists("casos_fraccionamiento")) {
  if ("Contratista" %in% names(casos_fraccionamiento)) casos_rucs <- as.character(casos_fraccionamiento$Contratista)
  else if ("RUC" %in% names(casos_fraccionamiento)) casos_rucs <- as.character(casos_fraccionamiento$RUC)
}

# --- Comprobar que existe la columna 'Contratista' en datos ---
if (!"Contratista" %in% names(datos)) stop("La columna 'Contratista' no existe en 'datos'. Revisa colnames(datos).")

# --- Crear Fecha_Emision (intentar varios formatos) ---
datos <- datos %>%
  mutate(
    Fecha_Emision = parse_date_time(
      `Fecha de suscripción del contrato`,
      orders = c("Y-m-d", "d/m/Y", "m/d/Y", "d-%m-%Y", "Y/%m/%d"),
      exact = FALSE
    ) %>% as.Date()
  )

# --- Limpiar monto y crear variables ---
datos_modelo <- datos %>%
  mutate(
    # limpiar texto de Monto y convertir a numérico (quita caracteres no numéricos)
    Monto_limpio = as.numeric(gsub(",", "", gsub("[^0-9.\\-]", "", as.character(Monto)))),
    # marcar sospechoso usando vectores seguros
    Es_Sospechoso = as.integer(Contratista %in% score_rucs | Contratista %in% casos_rucs),
    # variables temporales / derivadas
    Mes = lubridate::month(Fecha_Emision),
    Es_Fin_Año = ifelse(!is.na(Mes) & Mes >= 11, 1L, 0L),
    Dias_Desde_Inicio = as.numeric(Fecha_Emision - min(Fecha_Emision, na.rm = TRUE)),
    Monto_Normalizado = ifelse(!is.na(Monto_limpio), as.numeric(scale(Monto_limpio)[,1]), NA_real_),
    Participacion_Mercado = 0  # valor temporal
  )

# --- Opcional: ver resumen rápido ---
cat("Filas originales:", nrow(datos), "\n")
cat("Filas para modelo:", nrow(datos_modelo), "\n")
cat("Total Es_Sospechoso == 1:", sum(datos_modelo$Es_Sospechoso, na.rm = TRUE), "\n")

if (nrow(datos_modelo) > 10 && length(unique(na.omit(datos_modelo$Es_Sospechoso))) > 1) {
  set.seed(123)
  modelo_rf <- randomForest(
    factor(Es_Sospechoso) ~ Monto_Normalizado + Mes + Es_Fin_Año + Dias_Desde_Inicio + Participacion_Mercado,
    data = datos_modelo,
    ntree = 500,
    importance = TRUE
  )
  varImpPlot(modelo_rf)
  print(importance(modelo_rf))
} else {
  message("No se entrena el modelo: no hay suficientes filas o falta diversidad en Es_Sospechoso.")
}

```

```{r}
colnames(datos)
```


```{r}
datos <- datos %>%
  mutate(Año = lubridate::year(Fecha_Emision))

```

```{r}
datos %>% 
  group_by(Periodo = ifelse(Año < 2023, "Antes 2023", "Desde 2023")) %>% 
  summarise(
    Mediana = median(Monto_limpio, na.rm = TRUE),
    Promedio = mean(Monto_limpio, na.rm = TRUE)
  )

```


```{r}

library(dplyr)
library(stats)
library(lubridate)
library(benford.analysis)

# Asegurar que la columna de fecha sea tipo Date
datos <- datos %>%
  mutate(
    Fecha = as.Date(`Fecha de suscripción del contrato`, format = "%Y-%m-%d"),
    Año = year(Fecha)
  )

# Test de diferencia antes/después del año 2023
wilcox.test(
  datos %>% filter(Año < 2023) %>% pull(Monto),
  datos %>% filter(Año >= 2023) %>% pull(Monto)
)

# Test de Benford para detectar manipulación de cifras
benford_test <- benford(datos$Monto, number.of.digits = 1)
plot(benford_test)

cat("\nTest de Benford - Desviación significativa indica posible manipulación de cifras\n")
print(benford_test)
```


```{r}
# AGREGAR AL FINAL:
# ========================================
# INFORME EJECUTIVO FINAL
# ========================================

cat("\n")
cat("╔═══════════════════════════════════════════════════╗\n")
cat("║   INFORME EJECUTIVO - ANÁLISIS DE CORRUPCIÓN    ║\n")
cat("╚═══════════════════════════════════════════════════╝\n\n")

cat("1. HALLAZGOS PRINCIPALES:\n")
cat("   ├─ Concentración de mercado (IHH):", round(IHH, 0), "\n")
cat("   ├─ Proveedores que controlan 80% del gasto:", proveedores_80, "\n")
cat("   ├─ Casos de fraccionamiento detectados:", nrow(casos_fraccionamiento), "\n")
cat("   └─ Órdenes con sobreprecios:", nrow(ordenes_precio_anomalo), "\n\n")

cat("2. RECOMENDACIONES:\n")
cat("   □ Auditoría inmediata a los", nrow(score_integral), "proveedores de alto riesgo\n")
cat("   □ Investigar", nrow(proveedores_nuevos), "proveedores nuevos con contratos grandes\n")
cat("   □ Revisar concentración fin de año (", 
    round(mean(concentracion_fin_año$Porcentaje_Fin_Año), 1), "% promedio)\n")
cat("   □ Fortalecer controles en tipos de contratación con mayor incidencia\n\n")

cat("3. PROVEEDORES CRÍTICOS (Top 5 por riesgo):\n")
print(score_integral %>% 
      head(5) %>% 
      select(RUC, Razon_Social, SCORE_RIESGO_TOTAL, Monto_Total))

cat("\n4. MONTO ESTIMADO EN RIESGO:\n")
monto_riesgo <- sum(score_integral$Monto_Total)
cat("   S/", format(monto_riesgo, big.mark = ","), "\n")
cat("   (", round(monto_riesgo/sum(datos$Monto_limpio)*100, 2), "% del gasto total)\n\n")

```
```{r}
names(datos)

```


```{r}
# ========================================
# ANÁLISIS DE INTERVALOS DE CONFIANZA
# ========================================
ic_montos <- datos %>%
  group_by(Tipo_Contratacion) %>%
  summarise(
    n = n(),
    media = mean(Monto_limpio, na.rm = TRUE),
    sd = sd(Monto_limpio, na.rm = TRUE),
    error_std = sd / sqrt(n),
    ic_inferior = media - 1.96 * error_std,
    ic_superior = media + 1.96 * error_std
  )

print("INTERVALOS DE CONFIANZA (95%) PARA MONTOS PROMEDIO:")
print(ic_montos)

# Visualizar
ggplot(ic_montos, aes(x = Tipo_Contratacion, y = media)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymin = ic_inferior, ymax = ic_superior), width = 0.2) +
  labs(title = "Intervalos de Confianza para Monto Promedio por Tipo de Contratación",
       y = "Monto Promedio (S/)", x = "Tipo de Contratación") +
  theme_minimal()

```

